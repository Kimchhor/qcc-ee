//===-- QISAISelDAGToDAG.cpp - A dag to dag inst selector for QISA --------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the QISA target.
//
//===----------------------------------------------------------------------===//

#include "QISATargetMachine.h"
//#include "QISAISelLowering.h"
#include "QISA.h"
#include "llvm/Analysis/AliasAnalysis.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/KnownBits.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "QISA-isel"

namespace {

class QISADAGToDAGISel : public SelectionDAGISel {
  const QISASubtarget *Subtarget;

  const QISATargetMachine &getTargetMachine() const {
    return static_cast<const QISATargetMachine &>(TM);
  }

  //  const QISAInstrInfo *getInstrInfo() const {
  //    return Subtarget->getInstrInfo();
  //  }

public:
  QISADAGToDAGISel(QISATargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel) {}

/*
  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<QISASubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }
*/
  // Override MachineFunctionPass.
  StringRef getPassName() const override {
    return "QISA DAG->DAG Pattern Instruction Selection";
  }
  
  // Override SelectionDAGISel.
  void Select(SDNode *Node) override;
  
  bool SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset);

private:
  SDNode *SelectMeasureGate(SDNode *Node);
  SDNode *SelectConditionalBranch(SDNode *N);
  SDNode *SelectMoveImmediate(SDNode *N);


/*
bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                                  std::vector<SDValue> &OutOps) override;
bool IsProfitableToFold(SDValue N, SDNode *U, SDNode *Root) const override;
void PreprocessISelDAG() override;
*/

// Include the pieces autogenerated from the target description.
#include "QISAGenDAGISel.inc"
};
} // end anonymous namespace

FunctionPass *llvm::createQISAISelDag(QISATargetMachine &TM,
                                      CodeGenOpt::Level OptLevel) {
  return new QISADAGToDAGISel(TM, OptLevel);
}


bool QISADAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset) {
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    // EVT PtrVT = getTargetLowering()->getPointerTy(CurDAG->getDataLayout());
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, Addr, MVT::i32);
    return true;
  }
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress) {
    return false; // direct calls.
  }
  SDLoc DL(Addr);
  if (CurDAG->isBaseWithConstantOffset(Addr)) {
      ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
      if (isInt<16>(CN->getSExtValue())) {

        // If the first operand is a FI, get the TargetFI Node
        if (FrameIndexSDNode *FIN =
                dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
          Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        else
          Base = Addr.getOperand(0);

        Offset = CurDAG->getTargetConstant(CN->getSExtValue(), DL, MVT::i32);
        return true;
      }
    }

  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, Addr, MVT::i32);
  return true;
}


SDNode *QISADAGToDAGISel::SelectMeasureGate(SDNode *Node) {
  
  return Node;
}


SDNode *QISADAGToDAGISel::SelectMoveImmediate(SDNode *N) {
  // Make sure the immediate size is supported.
  ConstantSDNode *ConstVal = cast<ConstantSDNode>(N);
  uint64_t ImmVal = ConstVal->getZExtValue();
  uint64_t SupportedMask = 0xfffffffff;
  if ((ImmVal & SupportedMask) != ImmVal) {
    SelectCode(N);
    return N;
  }

  // Select the low part of the immediate move.
  uint64_t LoMask = 0xffff;
  uint64_t HiMask = 0xffff0000;
  uint64_t ImmLo = (ImmVal & LoMask);
  uint64_t ImmHi = (ImmVal & HiMask);
  SDValue ConstLo = CurDAG->getTargetConstant(ImmLo, N, MVT::i32);
  MachineSDNode *Move = CurDAG->getMachineNode(QISA::MOVHIi16, N, MVT::i32, SDValue(Move, 0),
                                  ConstLo);
  // Select the low part of the immediate move, if needed.
  if (ImmHi) {
    SDValue ConstHi = CurDAG->getTargetConstant(ImmHi >> 16, N, MVT::i32);
    Move = CurDAG->getMachineNode(QISA::MOVHIi16, N, MVT::i32, SDValue(Move, 0),
                                  ConstHi);
  }

  return Move;
}

SDNode *QISADAGToDAGISel::SelectConditionalBranch(SDNode *N) {
  SDValue Chain = N->getOperand(0);
  SDValue Cond = N->getOperand(1);
  SDValue LHS = N->getOperand(2);
  SDValue RHS = N->getOperand(3);
  SDValue Target = N->getOperand(4);
  
  // Generate a comparison instruction.
  EVT CompareTys[] = { MVT::Other, MVT::Glue };
  SDVTList CompareVT = CurDAG->getVTList(CompareTys);
  SDValue CompareOps[] = {LHS, RHS, Chain};
  SDNode *Compare = CurDAG->getMachineNode(QISAISD::CMP, N, CompareVT, CompareOps);
  
  // Generate a predicated branch instruction.
  CondCodeSDNode *CC = cast<CondCodeSDNode>(Cond.getNode());
  SDValue CCVal = CurDAG->getTargetConstant(CC->get(), N, MVT::i32);
  SDValue BranchOps[] = {CCVal, Target, SDValue(Compare, 0),
                         SDValue(Compare, 1)};
  return CurDAG->getMachineNode(QISAISD::BR_CC, N, MVT::Other, BranchOps);
}

void QISADAGToDAGISel::Select(SDNode *Node) {
  // Instruction Selection not handled by the auto-generated tablegen selection
  // should be handled here.

  switch (Node->getOpcode())
  {
    default:
      break;
  case ISD::LOAD:
  // errs() << "LOAD";
  break;
  // case ISD::Constant:
  //   Node = SelectMoveImmediate(Node);
  //   return;
  case ISD::FrameIndex:
    SDLoc DL(Node);
    SDValue Imm = CurDAG->getTargetConstant(0, DL, MVT::i32);
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    EVT VT = Node->getValueType(0);
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
    unsigned Opc = QISA::MOVHIi16;
    if (Node->hasOneUse()) {
      CurDAG->SelectNodeTo(Node, Opc, VT, TFI, Imm);
      return;
    }
    ReplaceNode(Node, CurDAG->getMachineNode(Opc, DL, VT, TFI, Imm));
    return;
  // case ISD::Constant: { // clone from AArch64SelDAGToDAG.cpp
  //   // Materialize zero constants as copies from WZR/XZR.  This allows
  //   // the coalescer to propagate these into other instructions.
  //   ConstantSDNode *ConstNode = cast<ConstantSDNode>(Node);

  //   if (ConstNode->isNullValue()) {
  //     if (VT == MVT::i32) {
  //       SDValue New = CurDAG->getCopyFromReg(
  //           CurDAG->getEntryNode(), SDLoc(Node), AArch64::WZR, MVT::i32);
  //       ReplaceNode(Node, New.getNode());
  //       return;
  //     } else if (VT == MVT::i64) {
  //       SDValue New = CurDAG->getCopyFromReg(
  //           CurDAG->getEntryNode(), SDLoc(Node), AArch64::XZR, MVT::i64);
  //       ReplaceNode(Node, New.getNode());
  //       return;
  //     }
  //   }
  //   break;
  // }
  }  
  // Select the default instruction.
  SelectCode(Node);
}
